//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     touch,          sensorTouch)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     leftMotor,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightMotor,    tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Copyright (c) 2014 Joshua Trahan. Licensed under the MIT License.
// For more information, visit github.com/r0but/tetrix-demo and read LICENSE.

/*
This code is meant to allow a user to control a simple Tetrix bot like they're
playing a driving video game. It is written for a simple Tetrix robot with two
motors: one controlling the left wheel, and one controlling the right wheel.
On my test bots, there is an omniwheel in the front-middle just to keep the whole
thing from falling over.

This is RobotC code. Despite the extension, trying to compile with a C
compiler will give errors. It is written for the LEGO NXT platform, but if you
want to try it on VEX or something give it a shot. I have no opportunity to use
a platform other than NXT and Arduino, and I don't use RobotC for my Arduino
projects, so I cannot provide any kind of support for anything but NXT.

The main task is at the bottom. Most of the motor controlling stuff is
in functions. The main loop is in the function mainLoop().

I haven't had much of a chance to test this code yet. It is functional,
but needs to be cleaned up, and probably has some bugs I haven't run into yet.

/****************************************************
*                                                   *
*    IMPORTANT: IN ROBOT CONFIG, NAME THE MOTORS    *
*       leftMotor AND rightMotor ACCORDINGLY.       *
*                                                   *
****************************************************/

#include "JoystickDriver.c"

// Deadzones for the control sticks
const int lowDeadzone = -5;
const int highDeadzone = 5;

// Max speed that the motors can EVER spin for the duration of the program.
// The actual speed itself is NOT constant.
const int maxSpeed = 100;
const int maxReverseSpeed = -100;

// Current speed for the motors to spin (determined in the main loop)
int speed;

void initializeRobot(){
  // Motors are not reversed by default. If your motor(s) are running backwards,
  // just change the corresponding motor to true OR tick "reversed" checkbox
  // for it in motor and sensor setup.
  bMotorReflected[rightMotor] = false;
  bMotorReflected[leftMotor] = false;
}

void turnLeft(int magnitude){
  // normalizes magnitude to a 1-100 value, then makes it so a higher value
  // makes the motor run slower
  magnitude *= -1;
  magnitude = speed - (magnitude * (speed / 128.0));

  motor[rightMotor] = speed;
  motor[leftMotor] = magnitude;
}

void turnRight(int magnitude){
  // does the same thing as the similar statement in turnLeft
  magnitude = speed - (magnitude * (speed / 127.0));

  motor[rightMotor] = magnitude;
  motor[leftMotor] = speed;
}

void goStraight(){
  motor[rightMotor] = speed;
  motor[leftMotor] = speed;
}

void spinLeft(){
  motor[rightMotor] = maxSpeed;
  motor[leftMotor] = maxReverseSpeed;
}

void spinRight(){
  motor[rightMotor] = maxReverseSpeed;
  motor[leftMotor] = maxSpeed;
}

void setSpeedFromJoystick(int magnitude){
  // Max negative value from the stick is -128, while max positive is 127.
  if (magnitude < 0){
    speed = magnitude * (maxSpeed / 128.0);
  }
  else{
    speed = magnitude * (maxSpeed / 127.0);
  }
}

void stopRobot(){
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
}

void mainLoop(){
  int leftStick = 0;
  int rightStick = 0;

  while(true){
    getJoystickSettings(joystick);
    wait1Msec(40);

    // Spins the robot in a circle (L2 spins counter-clockwise, R2 clockwise)
    if (joy1Btn(7)){
      spinLeft();
      continue;
    }
    else if (joy1Btn(8)){
      spinRight();
      continue;
    }

    // left stick left/right, right stick up/down
    leftStick = joystick.joy1_x1;
    rightStick = joystick.joy1_y2;

    // This group of if statements sets the speed
    if (rightStick < lowDeadzone || rightStick > highDeadzone){
      setSpeedFromJoystick(rightStick);
    }
    else if (joy1Btn(6)){
      speed = maxSpeed;
    }
    else if (joy1Btn(5)){
      speed = maxReverseSpeed;
    }
    else{
      stopRobot();
      continue;
    }

    // This group determines turning
    if (leftStick < lowDeadzone){
      turnLeft(leftStick);
    }
    else if (leftStick > highDeadzone){
      turnRight(leftStick);
    }
    else{
      goStraight();
    }
  }
}

task main(){
  initializeRobot();
  waitForStart();
  mainLoop();
}
